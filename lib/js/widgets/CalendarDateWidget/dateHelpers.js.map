{"version":3,"sources":["../../../../src/js/widgets/CalendarDateWidget/dateHelpers.js"],"names":["parseISODate","formatYear","formatDayMonth","formatISOPartialDate","setValidDate","autofillYearPast","autofillYearFuture","dateString","split","year","month","day","val","numberVal","Number","dayOrMonth","toString","length","undefined","newState","validation","value","validDate","Date","validMonth","getMonth","validDay","getDate","isDateInFuture","currentYear","getFullYear","isDateFromLastYear","isDateInPast"],"mappings":"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","file":"dateHelpers.js","sourcesContent":["import { set } from 'lodash';\nimport { isAfter, isBefore } from 'date-fns';\n\n// dateString will be either a string in the form '2011-11-11' or undefined\nexport function parseISODate(dateString) {\n  if (typeof dateString === 'string') {\n    const [year, month, day] = dateString.split('-', 3);\n    return {\n      month,\n      day,\n      year\n    };\n  }\n  return {\n    month: '',\n    day: '',\n    year: '',\n  };\n}\n\nexport function formatYear(val) {\n  return val;\n}\n\nexport function formatDayMonth(val) {\n  if (val === '') return '';\n  const numberVal = Number(val);\n  if (numberVal) {\n    const dayOrMonth = numberVal.toString();\n    if (Number(dayOrMonth) && dayOrMonth.length === 1) {\n      return `0${numberVal}`;\n    } else if (Number(dayOrMonth)) {\n      return dayOrMonth;\n    }\n  }\n  return '';\n}\n\nexport function formatISOPartialDate({ month, day, year }) {\n  if (month && day && year) {\n    return `${formatYear(year)}-${formatDayMonth(month)}-${formatDayMonth(day)}`;\n  }\n\n  return undefined;\n}\n\n// Make sure that date is valid. If invalid, plug in approximate date.\n// Approximation is made by js Date parser's convention.\n// Ex: '02-31-2019' => '03-31-2019'\nexport function setValidDate(newState, validation) {\n  const { year, month, day } = newState.value;\n  // A reminder that js Dates start months at index=0 ;)\n  const validDate = new Date(year, month - 1, day);\n\n  const validMonth = validDate.getMonth() + 1;\n  const validDay = validDate.getDate();\n\n  if (validMonth !== Number(month)) {\n    set(newState, ['value', 'month'], formatDayMonth(validMonth));\n  }\n  if (validDay !== Number(day)) {\n    set(newState, ['value', 'day'], formatDayMonth(validDay));\n  }\n\n  if (validation === 'pastOnly') {\n    // If date is in the future, go back to last year\n    const isDateInFuture = isAfter(\n      new Date(year, newState.value.month - 1, newState.value.day),\n      new Date()\n    );\n    if (isDateInFuture) {\n      // Only need to subtract 1 year,\n      // Because we do not allow years that are greater than the current year\n      set(newState, ['value', 'year'], year - 1);\n    }\n  } else if (validation === 'futureOnly') {\n    // Note: autocorrect won't work the same for future dates,\n    // unless we decided to start tracking \"focus\" on the year input box.\n  }\n\n  return newState;\n}\n\n/**\n  For validation=\"pastOnly\"\n  If the filled out month+day for this year are in the future, then set year to last year.\n  ex:\n    Today is 5/07/2019\n    newState = {value: {month: \"11\", day: \"1\"}}\n    11/01/2019 is after 05/07/2019, so its not valid for a \"pastOnly\" calendar.\n    So we set the year to 2018\n*/\nexport function autofillYearPast(newState) {\n  const currentYear = (new Date()).getFullYear();\n  const isDateFromLastYear = isAfter(\n    new Date(currentYear, newState.value.month - 1, newState.value.day),\n    new Date()\n  );\n  return isDateFromLastYear ? currentYear - 1 : currentYear;\n}\n\n/**\n  For validation=\"futureOnly\"\n  If the filled out month+day for this year are in the past, then set year to next year.\n  ex:\n    Today is 5/07/2019\n    newState = {value: {month: \"03\", day: \"1\"}}\n    03/01/2019 is before 05/07/2019, so its not valid for a \"futureOnly\" calendar.\n    So we set the year to 2020\n* */\nexport function autofillYearFuture(newState) {\n  const currentYear = (new Date()).getFullYear();\n  const isDateInPast = isBefore(\n    new Date(currentYear, newState.value.month - 1, newState.value.day),\n    new Date()\n  );\n  return isDateInPast ? currentYear + 1 : currentYear;\n}\n"]}